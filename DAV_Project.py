# -*- coding: utf-8 -*-
"""Project_DAV.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12r02GwoBehnPV30uYBS0Lq8OXjZxdfZh

# **DAV PROJECT**



..
# **Sub Divisional Monthly Rainfall from 1901 to 2017**


---
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from scipy.stats import chi2_contingency
from scipy.stats import chi2

# Preprocessing: Load the data from CSV


data = pd.read_csv('Sub_Division_IMD_2017.csv')
data.rename(columns={'SUBDIVISION': 'STATES'}, inplace=True)
data.set_index("STATES", inplace=True)

# Droping columns which are not usefull
# Remove duplicate values
data.drop(columns=["JF", "MAM","JJAS","OND"],inplace=True)
print(data)


# Cleaning Data: Fill missing/NA values with column means
for column in data.columns:
    if column != 'ANNUAL':
        column_avg = data[column].mean()
        data[column].fillna(column_avg, inplace=True)

        data['UPDATED_ANNUAL'] = data[['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC',]].sum(axis=1)

data.drop(columns=["ANNUAL"],inplace=True)
# Define the order of months
months_order = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC','UPDATED_ANNUAL']


# Data Transformation: Pivot the DataFrame
pivot_data = data.pivot_table(index=['STATES', 'YEAR'], values=months_order, aggfunc=np.sum)
pivot_data = pivot_data.reindex(columns=months_order)
# Save the processed data to CSV
pivot_data.to_csv("updated_file.csv")


# Display the processed data

# print(pivot_data)
print(pivot_data.to_string())

data.columns

"""## Analysis of State-wise Maximum Annual Rainfall"""

# Create lists to store results
pivot_data = data.pivot_table(index='YEAR', columns='STATES', values='UPDATED_ANNUAL', aggfunc='sum')
states = []
max_years = []
max_rainfalls = []

# Iterate over each column (state) in the pivot table
for state in pivot_data.columns:
    max_rainfall_year = pivot_data[state].idxmax()  # Year with highest rainfall
    max_rainfall = pivot_data[state].max()  # Maximum annual rainfall
    states.append(state)
    max_years.append(max_rainfall_year)
    max_rainfalls.append(max_rainfall)

# Create DataFrame to store the results
results = pd.DataFrame({'State': states, 'Year': max_years, 'Annual Rainfall': max_rainfalls})

# Print the results table
print(results.to_string(index=False))

"""## Visualization of State-wise Maximum Annual Rainfall"""

import matplotlib.pyplot as plt

# Sort the results by maximum rainfall in descending order
results_sorted = results.sort_values(by='Annual Rainfall', ascending=True)  # Change to True for horizontal plot

# Create the horizontal bar plot
plt.figure(figsize=(10, 8))
plt.barh(results_sorted['State'], results_sorted['Annual Rainfall'], color='skyblue')  # Use barh for horizontal
# Add annotations for the corresponding year
for i in range(len(results_sorted)):
    plt.text(results_sorted['Annual Rainfall'].iloc[i], i, str(results_sorted['Year'].iloc[i]), va='center')
plt.xlabel('Annual Rainfall (mm)')
plt.ylabel('State')
plt.title('State-wise Maximum Annual Rainfall and Corresponding Year')
plt.show()


import pandas as pd
import matplotlib.pyplot as plt

# Plotting the bar plot
plt.figure(figsize=(12, 8))
# plt.bar(data['STATES'], data['UPDATED_ANNUAL'], color='skyblue')
plt.xlabel('States')
plt.ylabel('Annual Rainfall (mm)')
plt.title('Annual Rainfall by State')
plt.xticks(rotation=90)  # Rotate x-axis labels for better readability
plt.tight_layout()
plt.show()

"""## Analysis of State-wise Maximum Annual Rainfall"""

# Create lists to store results
states = []
min_years = []
min_rainfalls = []

# Iterate over each column (state) in the pivot table
for state in pivot_data.columns:
    min_rainfall_year = pivot_data[state].idxmin()  # Year with lowest rainfall
    min_rainfall = pivot_data[state].min()  # Minimum annual rainfall
    states.append(state)
    min_years.append(min_rainfall_year)
    min_rainfalls.append(min_rainfall)

# Create DataFrame to store the results
min_results = pd.DataFrame({'State': states, 'Year': min_years, 'Annual Rainfall': min_rainfalls})

# Print the results table
print(min_results.to_string(index=False))

"""### Visualization of State-wise Maximum Annual Rainfall"""

import matplotlib.pyplot as plt

# Sort the results by minimum rainfall in ascending order
min_results_sorted = min_results.sort_values(by='Annual Rainfall', ascending=True)

# Create the horizontal bar plot
plt.figure(figsize=(10, 8))
plt.barh(min_results_sorted['State'], min_results_sorted['Annual Rainfall'], color='lightgreen')
# Add annotations for the corresponding year
for i in range(len(min_results_sorted)):
    plt.text(min_results_sorted['Annual Rainfall'].iloc[i], i, str(min_results_sorted['Year'].iloc[i]), va='center')
plt.xlabel('Annual Rainfall (mm)')
plt.ylabel('State')
plt.title('State-wise Minimum Annual Rainfall and Corresponding Year')
plt.show()

"""## Visualization of Annual Rainfall for All States in 2010"""

# Define the order of months
months_order = ['UPDATED_ANNUAL']

# Pivot the DataFrame
pivot_data = data.pivot_table(index=['STATES', 'YEAR'], values=months_order, aggfunc=sum)
pivot_data = pivot_data.reindex(columns=months_order)

# Filter pivot_data for a particular year
desired_year = 2010
annual_rainfall_for_year = pivot_data.loc[(slice(None), desired_year), :]

# Print annual rainfall for all states for the desired year
print(annual_rainfall_for_year)

"""## Visualizing Annual Rainfall Across States for a Specific Year

"""

import matplotlib.pyplot as plt

# Filter pivot_data for a particular year
desired_year = int(input("Enter the year: "))  # Take input for the desired year
annual_rainfall_for_year = pivot_data.loc[(slice(None), desired_year), :]

# Extract the annual rainfall values for the desired year
annual_rainfall_values = annual_rainfall_for_year.values.flatten()

# Extract the states as labels
states = annual_rainfall_for_year.index.get_level_values('STATES')

# Plot the pie chart
plt.figure(figsize=(14, 6))

# Plot the line chart
plt.subplot(1, 2, 1)
plt.plot(states, annual_rainfall_values, marker='o', linestyle='-')
plt.title(f'Annual Rainfall Across States for the Year {desired_year}')
plt.xlabel('States')
plt.ylabel('Annual Rainfall (mm)')
plt.xticks(rotation=90)
plt.grid(True)

# # Plot the pie chart
# plt.subplot(1, 2, 2)
# plt.pie(annual_rainfall_values, labels=states, autopct='%1.1f%%', startangle=140)
# plt.title(f'Distribution of Annual Rainfall Across States for the Year {desired_year}')
# plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle

plt.tight_layout()
plt.show()

"""## Random and Systematic Sampling of Annual Rainfall Data

"""

# Perform random sampling with a sample size of 10% of the data
random_sample = pivot_data.sample(frac=0.1, random_state=42)

# Print the random sample
print(random_sample)

sampling_interval = 10

# Perform systematic sampling
systematic_sample = pivot_data[pivot_data.index.get_level_values('YEAR') % sampling_interval == 0]

# Print the systematic sample
print(systematic_sample)

"""# Stacked Bar Chart of Total Rainfall by Month Over the Years"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Load the updated data from CSV
data = pd.read_csv('updated_file.csv')

# Define the months
months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']

# Group data by year and sum the rainfall for each month
year_total = data.groupby('YEAR')[months].sum()

# Plot stacked bars for total rainfall by month
ax = year_total.plot(kind='bar', stacked=True, figsize=(14, 8), colormap='tab20')
ax.set_title('Total rainfall by month')
ax.set_xlabel('Year')
ax.set_ylabel('Rainfall')
ax.legend(title='Months', loc='upper right')  # Set legend location to upper right
plt.xticks(rotation=90)
plt.tight_layout()
plt.show()

"""## Pie Chart of Percentage Total Rainfall by State (1901-2017"""

import pandas as pd
import matplotlib.pyplot as plt

# Load the updated data from CSV
data = pd.read_csv('updated_file.csv')

# Calculate total rainfall for each state across all years
state_total = data.groupby('STATES')['UPDATED_ANNUAL'].sum()

# Calculate the percentage of total rainfall for each state
percentages = (state_total / state_total.sum()) * 100

# Plotting the pie chart
plt.figure(figsize=(12, 10))
plt.pie(percentages, labels=percentages.index, autopct='%1.1f%%', startangle=140, labeldistance=1.1)
plt.title('Percentage of Total Rainfall by State (1901-2017)', fontsize=16)
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle
plt.show()

"""## Line Plot of Total Rainfall by Month (1901-2017)"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Load the updated data from CSV
data = pd.read_csv('updated_file.csv')

# Define the months
months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']

# Calculate total rainfall for each month across all years
month_total = data[months].sum()

# Plot the line plot
plt.figure(figsize=(12, 8))
plt.plot(month_total.index, month_total.values, marker='o', linestyle='-')
plt.title('Total Rainfall by Month (1901-2017)')
plt.xlabel('Month')
plt.ylabel('Total Rainfall (mm)')
plt.xticks(np.arange(len(months)), months)
plt.grid(True)
plt.show()

"""## Bar Plot of Total Rainfall by Year (1901-2019"""

import pandas as pd
import matplotlib.pyplot as plt

# Load the updated data from CSV
data = pd.read_csv('updated_file.csv')

# Define the decade of interest
start_decade = 1901
end_decade = 2019

# Filter data for the decade of interest
data_decade = data[(data['YEAR'] >= start_decade) & (data['YEAR'] <= end_decade)]

# Calculate total rainfall for each year in the decade
yearly_total_decade = data_decade.groupby('YEAR')['UPDATED_ANNUAL'].sum()

# Find the year with maximum and minimum rainfall in the decade
max_year_decade = yearly_total_decade.idxmax()
min_year_decade = yearly_total_decade.idxmin()

# Plot the bar plot
plt.figure(figsize=(12, 8))
plt.bar(yearly_total_decade.index, yearly_total_decade.values, color='skyblue')
plt.title(f'Total Rainfall by Year ({start_decade}-{end_decade})')
plt.xlabel('Year')
plt.ylabel('Total Rainfall (mm)')

# Annotate the maximum and minimum points
plt.text(max_year_decade, yearly_total_decade[max_year_decade], f'Max: {yearly_total_decade[max_year_decade]:.2f} mm', ha='center', va='bottom')
plt.text(min_year_decade, yearly_total_decade[min_year_decade], f'Min: {yearly_total_decade[min_year_decade]:.2f} mm', ha='center', va='bottom')

# Set x-axis ticks to include every year in the decade with rotation and alignment
plt.xticks(yearly_total_decade.index, rotation=90, ha='right')

plt.tight_layout()
plt.show()

"""## Correlation Heatmap for July to December"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load the updated data from CSV
data = pd.read_csv('updated_file.csv')

# Filter the data for the months July to December
months_of_interest = ['JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']
data_filtered = data[months_of_interest]

# Compute the correlation matrix
corr_matrix = data_filtered.corr()

# Plot the heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(data=corr_matrix, annot=True, fmt=".2f", linewidths=.5, cmap='Blues')
plt.title('Heatmap for July to December')
plt.show()

"""## QQ Plot of Annual Rainfall"""

import pandas as pd
import matplotlib.pyplot as plt
import scipy.stats as stats
import statsmodels.api as sm

# Assuming you have loaded your data into a DataFrame named 'data'
# Extract the annual rainfall and year columns
annual_rainfall = data['UPDATED_ANNUAL']
year = data['YEAR']

# Create a QQ plot
plt.figure(figsize=(8, 6))
stats.probplot(annual_rainfall, dist="norm", plot=plt)
plt.title('QQ Plot of Annual Rainfall')
plt.xlabel('Theoretical Quantiles')
plt.ylabel('Ordered Values (Annual Rainfall)')
plt.grid(True)
plt.show()

!pip install joypy
!pip install squarify

"""## Joyplot of Monthly Rainfal"""

import pandas as pd
import joypy
import matplotlib.pyplot as plt

# Assuming you have loaded your data into a DataFrame named 'data'
# Extract the columns for months and rainfall
months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']
rainfall_data = data[months]

# Create a joyplot
plt.figure(figsize=(100,80))
joypy.joyplot(rainfall_data, overlap=1, colormap=plt.cm.rainbow, linecolor='w', linewidth=1)
plt.title('Joyplot of Monthly Rainfall')
plt.xlabel('Rainfall (mm)')
plt.ylabel('Months')
plt.show()

"""
## "Mosaic Plot: Rainfall Distribution by Month and State"
"""

import pandas as pd
from statsmodels.graphics.mosaicplot import mosaic

# Load the updated data from CSV
data = pd.read_csv('updated_file.csv')

# Filter the data for the desired years
data_filtered = data[(data['YEAR'] >= 2010) & (data['YEAR'] <= 2017)]

# Define the combination of months you want to visualize
months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']

# Melt the data to long format for mosaic plot
data_melted = pd.melt(data_filtered, id_vars=['STATES', 'YEAR'], value_vars=months, var_name='Month', value_name='Rainfall')

# Create a mosaic plot
mosaic(data_melted, ['Month', 'STATES'], title='Rainfall Distribution by Month and State')

"""### Treemap of Annual Rainfall by Year"""

import pandas as pd
import matplotlib.pyplot as plt


import squarify

# Assuming you have loaded your data into a DataFrame named 'data'
# Extract the columns for years and annual rainfall
years = data['YEAR']
annual_rainfall = data['UPDATED_ANNUAL']

# Create a DataFrame with years and annual rainfall
df = pd.DataFrame({'YEAR': years, 'Annual Rainfall': annual_rainfall})

# Calculate the total annual rainfall for each year
yearly_total_rainfall = df.groupby('YEAR')['Annual Rainfall'].sum().reset_index()

# Sort the DataFrame by year
yearly_total_rainfall = yearly_total_rainfall.sort_values(by='YEAR')

# Create the treemap
plt.figure(figsize=(12, 8))
squarify.plot(sizes=yearly_total_rainfall['Annual Rainfall'], label=yearly_total_rainfall['YEAR'], alpha=0.7)
plt.title('Treemap of Annual Rainfall by Year')
plt.axis('off')
plt.show()

!pip install squarify

"""### Strip Plot of Monthly Rainfall for the Year 2010"

## Strip Plot of Monthly Rainfall (2000-2017)
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Load the dataset
data = pd.read_csv('updated_file.csv')

# Melt the dataframe to long format for plotting
data_melted = data.melt(id_vars=['YEAR'], var_name='Month', value_name='Rainfall')

# Filter the dataset for the years 2000 to 2017
data_filtered = data_melted[data_melted['YEAR'].between(2000, 2017)].copy()

# Convert 'YEAR' column to categorical type
data_filtered['YEAR'] = pd.Categorical(data_filtered['YEAR'])

# Convert 'Rainfall' column to numeric data type
data_filtered['Rainfall'] = pd.to_numeric(data_filtered['Rainfall'], errors='coerce')

# Remove rows with NaN values in 'Rainfall' column
data_filtered = data_filtered.dropna(subset=['Rainfall'])

# Set the figure size
plt.figure(figsize=(12, 8))

# Create the strip plot with custom aesthetics
sns.stripplot(data=data_filtered, x='Month', y='Rainfall', hue='YEAR', jitter=True, linewidth=1, size=4, palette='Set2')

# Add title and labels
plt.title('Strip Plot of Monthly Rainfall (2000-2017)', fontsize=16)
plt.xlabel('Month', fontsize=14)
plt.ylabel('Rainfall (mm)', fontsize=14)
plt.xticks(rotation=45)

# Show the plot
plt.tight_layout()
plt.show()

"""## Strip Plot of Monthly Rainfall for [State] ([Month])"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Load the dataset
data = pd.read_csv('updated_file.csv')

# List to store the plots for each month
plots = []

# Iterate over each month
for month in data.columns[2:-1]:  # Exclude 'YEAR' and 'ANNUAL' columns
    # Find the state with the highest rainfall for the current month
    highest_rainfall_state = data.sort_values(by=month, ascending=False).iloc[0]['STATES']

    # Filter the dataset to include only data for the identified state and the current month
    filtered_data = data[(data['STATES'] == highest_rainfall_state) & (data['YEAR'] >= 2000) & (data['YEAR'] <= 2017)]

    # Melt the filtered dataframe to long format for plotting
    filtered_data_melted = filtered_data.melt(id_vars=['YEAR'], var_name='Month', value_name='Rainfall')

    # Convert 'YEAR' column to categorical type
    filtered_data_melted['YEAR'] = pd.Categorical(filtered_data_melted['YEAR'])

    # Convert 'Rainfall' column to numeric data type
    filtered_data_melted['Rainfall'] = pd.to_numeric(filtered_data_melted['Rainfall'], errors='coerce')

    # Remove rows with NaN values in 'Rainfall' column
    filtered_data_melted = filtered_data_melted.dropna(subset=['Rainfall'])

    # Create the strip plot for the current month
    plt.figure(figsize=(8, 6))
    sns.stripplot(data=filtered_data_melted, x='Month', y='Rainfall', jitter=True, linewidth=1, size=4, palette='Set2')
    plt.title(f'Strip Plot of Monthly Rainfall for {highest_rainfall_state} ({month})', fontsize=16)
    plt.xlabel('Month', fontsize=14)
    plt.ylabel('Rainfall (mm)', fontsize=14)
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

    # Append the plot to the list
    plots.append(plt)

"""## Rainfall Across Months for the Year [Random Year]"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import random

# Load the dataset
data = pd.read_csv('updated_file.csv')

# Get a random year from the dataset
random_year = random.choice(data['YEAR'])

# Filter the dataset for the random year
random_year_data = data[data['YEAR'] == random_year]

# Melt the dataframe to long format for plotting
random_year_data_melted = random_year_data.melt(id_vars=['YEAR'], var_name='Month', value_name='Rainfall')

# Convert 'Rainfall' column to numeric data type
random_year_data_melted['Rainfall'] = pd.to_numeric(random_year_data_melted['Rainfall'], errors='coerce')

# Remove rows with NaN values in 'Rainfall' column
random_year_data_melted = random_year_data_melted.dropna(subset=['Rainfall'])

# Create the plot
plt.figure(figsize=(10, 6))
sns.barplot(data=random_year_data_melted, x='Month', y='Rainfall', palette='viridis')
plt.title(f'Rainfall Across Months for the Year {random_year}', fontsize=16)
plt.xlabel('Month', fontsize=14)
plt.ylabel('Rainfall (mm)', fontsize=14)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""## Rainfall Distribution in [Random State] Across All Year"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import random

# Load the dataset
data = pd.read_csv('updated_file.csv')

# Get a list of all unique states
unique_states = data['STATES'].unique()

# Select a random state from the list
selected_state = random.choice(unique_states)

# Filter the data for the selected state
state_data = data[data['STATES'] == selected_state]

# Sum the rainfall across all years
annual_rainfall = state_data[['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']].sum()

# Ensure annual_rainfall is non-negative
annual_rainfall[annual_rainfall < 0] = 0

# Plot the pie chart with increased label distance
plt.figure(figsize=(10, 6))
plt.pie(annual_rainfall, labels=annual_rainfall.index, autopct='%1.1f%%', startangle=140, labeldistance=1.2)
plt.title(f'Rainfall Distribution in {selected_state} Across All Years')
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
plt.show()

"""Annual Rainfall Distribution by Year and State (2010-2017)

## Boxplot of Annual Rainfall by State
"""

import seaborn as sns
import matplotlib.pyplot as plt

# Assuming 'data' is your DataFrame containing the necessary columns
sns.boxplot(x="STATES", y="UPDATED_ANNUAL", data=data)
plt.title('Boxplot of Annual Rainfall by State')
plt.xlabel('State')
plt.ylabel('Annual Rainfall (mm)')
plt.xticks(rotation=90)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats

# Select the column for analysis for a particular state
state_data_column = pivot_data.loc['Andaman & Nicobar Islands', 'UPDATED_ANNUAL']

# Fit a normal distribution to the data
mu, std = stats.norm.fit(state_data_column)
xmin, xmax = state_data_column.min(), state_data_column.max()

# Create a different number of points along the x-axis
x = np.linspace(xmin, xmax, 50)

# Calculate the probability density function (PDF) of the normal distribution
p = stats.norm.pdf(x, mu, std)

# Plot the PDF
plt.plot(x, p, 'k', linewidth=2)
plt.title("Fit results: mu = %.2f, std = %.2f" % (mu, std))
plt.xlabel("Annual Rainfall")
plt.ylabel("Probability Density")
plt.show()

# Select the column for analysis for a particular state
state_data_column = pivot_data.loc['Jharkhand', 'UPDATED_ANNUAL']

# Calculate the range
data_range = state_data_column.max() - state_data_column.min()

# Calculate the interquartile range (IQR)
Q1 = state_data_column.quantile(0.25)
Q3 = state_data_column.quantile(0.75)
IQR = Q3 - Q1

# Print the results
print("Range:", data_range)
print("Interquartile Range (IQR):", IQR)

# Calculate mean
mean_updated_annual = pivot_data['UPDATED_ANNUAL'].mean()

# Calculate median
median_updated_annual = pivot_data['UPDATED_ANNUAL'].median()

# Calculate standard deviation
std_updated_annual = pivot_data['UPDATED_ANNUAL'].std()

# Calculate variance
variance_updated_annual = pivot_data['UPDATED_ANNUAL'].var()

# Print the results
print("Mean:", mean_updated_annual)
print("Median:", median_updated_annual)
print("Standard Deviation:", std_updated_annual)
print("Variance:", variance_updated_annual)

"""The Central Limit Theorem (CLT) is a fundamental theorem in statistics that describes the distribution of sample means from any population, regardless of its shape. It states that if you take sufficiently large random samples from any population, the distribution of the sample means will be approximately normally distributed, regardless of the shape of the original population distribution."""

import numpy as np
import matplotlib.pyplot as plt

# Define your dataset (replace 'data' with your actual dataset)
data = pivot_data['UPDATED_ANNUAL'].values

# Define parameters
sample_size = 30  # Adjust the sample size as needed
num_samples = 1000  # Number of samples to take

# Initialize array to store sample means
sample_means = np.zeros(num_samples)

# Take multiple samples and calculate sample means
for i in range(num_samples):
    sample = np.random.choice(data, size=sample_size, replace=False)
    sample_means[i] = np.mean(sample)

# Plot histogram of sample means
plt.hist(sample_means, bins=30, density=True, alpha=0.7, color='blue', edgecolor='black')

# Overlay theoretical normal distribution
mu = np.mean(sample_means)
sigma = np.std(sample_means)
x = np.linspace(mu - 3*sigma, mu + 3*sigma, 100)
plt.plot(x, 1/(sigma * np.sqrt(2 * np.pi)) * np.exp(-(x - mu)**2 / (2 * sigma**2)), color='red', linewidth=2)

# Add labels and title
plt.xlabel('Sample Mean')
plt.ylabel('Density')
plt.title('Distribution of Sample Means (CLT)')
plt.legend(['Normal Distribution', 'Sample Means'])

# Show plot
plt.show()

"""Permutation test and t-test are both statistical methods used to compare two groups or samples and determine if there is a significant difference between them. Here's an explanation of each, along with an explanation of the provided code:

Permutation Test: The permutation test is a non-parametric statistical test that assesses the significance of the difference between two groups by repeatedly shuffling the data between the groups and calculating a test statistic for each permutation. The null hypothesis in a permutation test is that there is no difference between the groups. The p-value is calculated as the proportion of permutation samples where the test statistic is as extreme as or more extreme than the observed statistic. Permutation tests are useful when the assumptions of parametric tests like t-tests are violated, such as when the data is not normally distributed or when the sample sizes are small. t-test: The t-test is a parametric statistical test used to determine if there is a significant difference between the means of two independent groups. The null hypothesis in a t-test is that there is no difference between the means of the two groups. The t-test calculates a t-statistic, which measures the difference between the means of the two groups relative to the variation within the groups. The p-value associated with the t-statistic indicates the probability of observing such a difference between the groups if the null hypothesis were true. T-tests are commonly used when the data is normally distributed and the sample sizes are reasonably large.
"""

import pandas as pd
from scipy.stats import ttest_ind
import matplotlib.pyplot as plt

# Load the data
data = pd.read_csv('updated_file.csv')

# Choose two states for comparison
state_A = 'Assam & Meghalaya'
state_B = 'Andaman & Nicobar Islands'

# Extract annual rainfall data for the two states
rainfall_A = data.loc[data['STATES'] == state_A, 'UPDATED_ANNUAL']
rainfall_B = data.loc[data['STATES'] == state_B, 'UPDATED_ANNUAL']

# Permutation Test
# You need to define a function to calculate the test statistic for permutation test
def perm_test_statistic(data1, data2):
    return abs(data1.mean() - data2.mean())

observed_statistic = abs(rainfall_A.mean() - rainfall_B.mean())
permutation_results = []
num_permutations = 1000

for _ in range(num_permutations):
    # Concatenate the data from two states and shuffle them
    combined_data = pd.concat([rainfall_A, rainfall_B])
    combined_data = combined_data.sample(frac=1)  # Shuffle the data

    # Split the shuffled data into two groups
    perm_rainfall_A = combined_data[:len(rainfall_A)]
    perm_rainfall_B = combined_data[len(rainfall_A):]

    # Calculate the test statistic for the permutation sample
    perm_statistic = perm_test_statistic(perm_rainfall_A, perm_rainfall_B)
    permutation_results.append(perm_statistic)

# Calculate the p-value
p_value_permutation = sum(perm_statistic >= observed_statistic for perm_statistic in permutation_results) / num_permutations

# t-test
t_statistic, p_value_ttest = ttest_ind(rainfall_A, rainfall_B)

# Plot histograms of the permutation distribution
plt.figure(figsize=(10, 6))
plt.hist(permutation_results, bins=20, color='skyblue', alpha=0.7, label='Permutation Distribution')
plt.axvline(x=observed_statistic, color='red', linestyle='--', linewidth=2, label='Observed Statistic')
plt.xlabel('Difference in Means')
plt.ylabel('Frequency')
plt.title('Permutation Test: Difference in Means between Two States')
plt.legend()
plt.grid(True)
plt.show()

# Print the results
print(f"Permutation Test:")
print(f"Observed Statistic: {observed_statistic}")
# print(f"P-value: {p_value_permutation}\n")

print(f"T-test:")
print(f"T-statistic: {t_statistic}")
print(f"P-value: {p_value_ttest}")

"""Permutation test and t-test are both statistical methods used to compare two groups or samples and determine if there is a significant difference between them. Here's an explanation of each, along with an explanation of the provided code:

Permutation Test: The permutation test is a non-parametric statistical test that assesses the significance of the difference between two groups by repeatedly shuffling the data between the groups and calculating a test statistic for each permutation. The null hypothesis in a permutation test is that there is no difference between the groups. The p-value is calculated as the proportion of permutation samples where the test statistic is as extreme as or more extreme than the observed statistic. Permutation tests are useful when the assumptions of parametric tests like t-tests are violated, such as when the data is not normally distributed or when the sample sizes are small. t-test: The t-test is a parametric statistical test used to determine if there is a significant difference between the means of two independent groups. The null hypothesis in a t-test is that there is no difference between the means of the two groups. The t-test calculates a t-statistic, which measures the difference between the means of the two groups relative to the variation within the groups. The p-value associated with the t-statistic indicates the probability of observing such a difference between the groups if the null hypothesis were true. T-tests are commonly used when the data is normally distributed and the sample sizes are reasonably large.
"""

import pandas as pd
from scipy.stats import chi2_contingency
import matplotlib.pyplot as plt

# Load the data
data = pd.read_csv('updated_file.csv')

# Choose two states for comparison
state_A = 'Assam & Meghalaya'
state_B = 'Andaman & Nicobar Islands'

# Extract annual rainfall data for the two states
rainfall_A = data.loc[data['STATES'] == state_A, 'UPDATED_ANNUAL']
rainfall_B = data.loc[data['STATES'] == state_B, 'UPDATED_ANNUAL']

# Perform chi-square test
observed_frequencies = pd.crosstab(data['STATES'], data['YEAR'])
chi2, p_value_chi2, _, _ = chi2_contingency(observed_frequencies)

# Print the results
print(f"Chi-square Test:")
print(f"Chi-square statistic: {chi2}")
# print(f"P-value: {p_value_chi2}\n")

# Plot histograms of the rainfall data for the two states
plt.figure(figsize=(10, 6))
plt.hist(rainfall_A, bins=20, color='skyblue', alpha=0.7, label=state_A)
plt.hist(rainfall_B, bins=20, color='salmon', alpha=0.7, label=state_B)
plt.xlabel('Annual Rainfall')
plt.ylabel('Frequency')
plt.title('Annual Rainfall Distribution for Two States')
plt.legend()
plt.grid(True)
plt.show()

"""Bootstrap sampling is a resampling technique used in statistics to estimate the distribution of a statistic by repeatedly resampling the dataset with replacement. It's particularly useful when analytical methods are unavailable or computationally expensive. Here's a breakdown of the code and an explanation of how bootstrap sampling works:"""

# Choose a state for analysis
state_name = 'Assam & Meghalaya'

# Extract annual rainfall data for the selected state
state_data = data.loc[data['STATES'] == state_name, 'UPDATED_ANNUAL'].values

# Number of bootstrap samples
num_samples = 1000

# Bootstrap sampling
bootstrap_samples = [np.random.choice(state_data, size=len(state_data), replace=True) for _ in range(num_samples)]

# Calculate the mean of each bootstrap sample
bootstrap_means = [np.mean(sample) for sample in bootstrap_samples]

# Calculate the confidence interval (e.g., 95% confidence interval)
confidence_interval = np.percentile(bootstrap_means, [2.5, 97.5])


lower_bound = confidence_interval[0]
upper_bound = confidence_interval[1]

# Print the lower and upper bounds
print("Lower Bound of 95% Confidence Interval:", lower_bound)
print("Upper Bound of 95% Confidence Interval:", upper_bound)

import matplotlib.pyplot as plt

# Plot the histogram of bootstrap sample means
plt.hist(bootstrap_means, bins=30, edgecolor='black', alpha=0.7)
plt.xlabel('Mean Annual Rainfall')
plt.ylabel('Frequency')
plt.title('Bootstrap Sampling Distribution')
plt.axvline(confidence_interval[0], color='red', linestyle='--', label='95% Confidence Interval (Lower)')
plt.axvline(confidence_interval[1], color='red', linestyle='--', label='95% Confidence Interval (Upper)')
plt.legend()
plt.show()

import pandas as pd
import numpy as np
import scipy.stats as stats

# Load your dataset
data = pd.read_csv('updated_file.csv')

# Group by 'STATES' and calculate mean and standard deviation of 'UPDATED_ANNUAL' rainfall
state_means = data['UPDATED_ANNUAL'].groupby(data['STATES']).mean()
state_std = data['UPDATED_ANNUAL'].groupby(data['STATES']).std()

# Calculate statistics
grand_mean = state_means.mean()
# Sum of Squares (SS) of error for each treatment (Residual)
ss_between = sum(len(data) * (state_means - grand_mean) ** 2)
ss_within = (state_std ** 2).sum()
# Degree of freedom
df_between = len(data['STATES'].unique()) - 1
df_within = len(data) - len(data['STATES'].unique())
# Mean of Sum of squares of error group wise (Residual)
ms_between = ss_between / df_between
ms_within = ss_within / df_within
f_stat = ms_between / ms_within
p_value = 1 - stats.f.cdf(f_stat, df_between, df_within)

# Print results
print('Grand Mean:', grand_mean)
print('SS_between:', ss_between)
print('SS_within:', ss_within)
print('df_between:', df_between)
print('df_within:', df_within)
print('MS_between:', ms_between)
print('MS_within:', ms_within)
print('F-statistic:', f_stat)
print('p-value:', p_value)